## React v16 Методы жизненного цикла.

Эта статья для разработчиков с базовыми знаниями React. Вы познакомитесь с методами жизненного цикла компонентов React, где они вызываются, как они используются, а также с продуманным процессом их реализации.
Это обзор всех методов жизненного цикла в React 16, для чего они используются и как их можно использовать в вашем рабочем процессе.

### Вступление

React - это библиотека JavaScript от Facebook с более чем 146 000 звезд на GitHub. Это декларативная, эффективная и гибкая структура для создания пользовательских интерфейсов. На самом деле очень безболезненно создавать интерактивные пользовательские интерфейсы, создавать компоненты-ориентированные приложения, которые являются как отзывчивыми, так и обратно совместимыми. В настоящее время это, пожалуй, самая популярная среда JavaScript, согласно опросу JS.

Эта статья для разработчиков с базовыми рабочими знаниями React. Вы познакомитесь с методами жизненного цикла компонентов React, где они вызываются, как они используются, а также с продуманным процессом их реализации.

### React методы жизненного цикла компонента

Методы жизненного цикла React компонентов можно описать как события, которые происходят от начала любого компонента до смерти этого же компонента. Жизненный цикл компонента React происходит в рамках этих событий, которые делятся на четыре категории:

1.Монтирование: Методы и события, которые происходят здесь, происходят, когда компонент монтируется в DOM.

2.Обновление: здесь методы и события происходят после того, как компонент React вошел в DOM.

3.Размонтирование: здесь методы и события происходят, когда компонент React покидает DOM или отключается от DOM.

4.Границы ошибок: это специальная категория, которая занимается обработкой или отловом ошибок, чтобы не полностью нарушить визуализацию приложения React.

В этом посте методы жизненного цикла React будут объяснены в том порядке, в котором они вызываются React в DOM.

### constructor()

Для компонентов класса React, которые не являются функциональными компонентами, конструктор является самым первым методом, который вызывается к действию в представлении компонента приложения. Конструктор принимает props как объект, и вам нужно вызвать родительский класс через super, чтобы установить доступ к this.props для props внутри класса. Конструктор выглядит так:

```js
class FirstComponent extends Component {
    constructor(props) {
        console.log('конструктор вызывается здесь!')
        super(props)
        this.state = {
            counter: 0,
        }
    }
}
```

Вызов super метода очень важен, и в него должны быть переданы пропсы. Также важно знать, что состояние может быть установлено только внутри конструкторов. Вы также можете устанавливать значения состояний, связывать методы и даже создавать ссылки внутри конструктора.

### getDerivedStateFromProps()

Самым следующим методом, вызываемым после конструктора, является метод getDerivedStateFromProps, это статический метод, и вы не можете использовать его внутри него. Это также последний метод, вызываемый перед методом рендеринга. Это своего рода особый вариант использования, который должен возвращать объект состояния в начальный пропс и устанавливать состояние, это также можно сделать с помощью конструктора, но конструктор делает гораздо больше вещей, помимо установки состояния. Это не очень часто используемый метод, так как многие разработчики React просто используют конструктор. Он принимает два параметра, props и state, а синтаксис выглядит следующим образом:

```js
 static getDerivedStateFromProps(props, state) {
        console.log("getDerivedStateFromProps вызывается здесь");
        return null;
      }
```

Он вызывается при каждом рендеринге и может быть помещен в метод конструктора.

### render()

Это самый важный метод любого класса React, вся работа, которая появится в DOM, выполняется здесь, так как он выводит JSX вашего компонента. Это наиболее используемый метод жизненного цикла React, и это единственный обязательный метод в любом классе React.

```js
 render(){
     console.log("метод render вызывается здесь");
     return Hello world!

    }
```

Однако вы не можете устанавливать состояние внутри метода рендеринга, поскольку оно должно быть чистым. Чистые функции - это функции без побочных эффектов, они всегда должны возвращать одинаковые данные, когда в них передаются одинаковые соответствующие данные.

### componentDidMount()

Этот метод вызывается сразу после вызова метода render, как только компонент монтируется. Внутри этого метода вы можете выполнять все необходимые закулисные работы без DOM. Эти вещи могут варьироваться от установки состояния, инициализации и загрузки данных и даже до добавления прослушивателей событий. Синтаксис выглядит так:

```js
componentDidMount() {
     console.log("componentDidMount вызывается здесь");
    }
```

Если setState вызывается внутри этого метода, DOM повторно перерисован для отражения модификации. Этот метод идеально подходит для выполнения вызовов AJAX.

### shouldComponentUpdate()

Этот метод вызывается сразу после метода componentDidMount, этот метод не позволяет устанавливать в нем состояние. Это полезно, когда вы не хотите, чтобы ваши реквизиты или изменения состояния повторно отображались, это похоже на мост, где вы должны получить разрешение, если компонент должен быть обновлен на основе изменений пропса или состояния. Возвращает логическое значение, обычно истинное по умолчанию. Синтаксис выглядит так:

```js
shouldComponentUpdate(nextProps, nextState) {
      console.log("shouldComponentUpdate вызывается здесь!");
      return nextState.cars.length < this.state.cars.length;
    }
```

Он принимает два аргумента, nextProps и nextState, и с их помощью вы можете сделать условия возврата для повторного рендеринга. Рекомендуется использовать этот метод с осторожностью, а в целях оптимизации помните, что он может вызывать повторную перерисовку.

### getSnapshotBeforeUpdate()

Этот метод является очень часто используемым методом, он вызывается только между периодом, в течение которого компонент отображается, и когда он обновляется в DOM. Это своего рода скриншот того, как выглядит предыдущее состояние и пропс перед обновлением. Синтаксис может выглядеть так:

```js
getSnapshotBeforeUpdate(prevProps, prevState){
      console.log("getSnapshotBeforeUpdate вызывается здесь!");
      if (prevState.cars.length < this.state.cars.length) {
        return { lastVehicle };
      }
      return null;
    }
```

Он принимает два параметра: prevProps и prevState и по умолчанию возвращает значение из условного оператора или null. Возвращаемое значение всегда передается методу componentDidUpdate.

### componentDidUpdate()

Это следующий метод, который вызывается сразу после метода getSnapshotBeforeUpdate, сразу после обновления DOM. Здесь можно настроить логику действий на обновленном DOM. Синтаксис такой:

```js
 componentDidUpdate(prevProps, prevState, snapshot) {
      console.log("componentDidUpdate вызывается здесь!");
    if (snapshot.lastVehicle) {
        return  No cars left!

      }
    }
```

Он имеет три параметра: prevProps, prevState и снимок. Снимок - это значение, возвращаемое методом getSnapshotBeforeUpdate. Здесь вы можете установить состояние, но оно всегда должно быть внутри условного оператора.

### componentWillUnmount()

Этот метод вызывается непосредственно перед размонтированием компонента из DOM, это метод, вызываемый сразу после componentDidUpdate. Вот где должна идти ваша логика очистки: очистка счетчиков и кэшей, отмена запросов API или удаление таких вещей, как прослушиватели событий. Это может выглядеть так:

```js
  componentWillUnmount(){
      console.log("componentWillUnmount вызывается здесь!");
      window.removeEventListener("restart");
    }
```

Как вы уже догадались, вы не можете установить состояние в этом методе, потому что это будет автоматически вызывать повторную визуализацию в большинстве случаев. После этого ваш компонент исчезнет, навсегда.

### getDerivedStateFromError()

Это один из двух новых методов жизненного цикла, используемых для изящной обработки ошибок, называемых предохранителями. Если дочерний компонент родительского компонента имеет ошибку, мы можем использовать этот метод для отображения экрана ошибки. Синтаксис выглядит так:

```js
 static getDerivedStateFromError(error) {
        // Обновите состояние, чтобы на следующем рендере отображался резервный интерфейс.
        return { hasError: true };
      }

      render() {
        if (this.state.hasError) {
          // Вы можете визуализировать любой пользовательский интерфейс
          return # Something went wrong.
        }

        return this.props.children;
      }
```

Здесь мы улавливаем ошибку дочернего компонента и изящно показываем клиенту сообщение об ошибке вместо того, чтобы ломать приложение или отображать пустой экран.

### componentDidCatch()

Это второй метод жизненного цикла, который является Предохранителями React. Это расширяет возможности первой границы ошибки выше, позволяя регистрировать ошибки. Синтаксис выглядит так:

```js
 componentDidCatch(error, info) {
        console.log(info.componentStack);
      }
```

Таким образом, помимо показа вашему клиенту приличного сообщения «что-то пошло не так» в пользовательском интерфейсе, вы также получаете платформу для информирования разработчика, проверяющего компонент, о конкретной информации об ошибке. В основном он используется в дополнение к методу getDerivedStateFromError.

### Вывод

Вы видели все методы жизненного цикла в React 16, их синтаксис и то, как они все работают в хронологическом порядке вызовов методов. Предохранители являются относительно новыми, и вы должны предъявить иск, чтобы включить их в свой рабочий процесс, они были признаны очень полезными. Вы можете увидеть визуальное представление этих методов здесь.

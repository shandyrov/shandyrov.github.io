## React Router v5 ч1.

В этом статье мы расскажем о версии 5.1, а также о некоторым приёмам, которые нужно изучить, чтобы подготовиться к будущему применению.

Команда разработчик усердно работает над тем, чтобы включить в версию 6 лучшие идеи из @ reach / router, а также рекомендации сообщества API 4/5, которые будут готовы где-то в начале нового года.

### Введение в React Router 5.1

Безусловно, наиболее заметной особенностью в этом выпуске является добавление хуков (для пользователей React 16.8).

По своей сути React Router является контейнером состояния для текущего местоположения или URL-адреса. Он отслеживает местоположение и отображает различные <Route> по мере его изменения, а также предоставляет инструменты для обновления местоположения с использованием <Link> и API истории. Учитывая тот факт, что управление этим фрагментом состояния является основной обязанностью маршрутизатора, вы можете себе представить, что новый примитив, который позволяет нам составлять состояние, позволит сделать несколько вещей, которые мы не могли сделать раньше!

Давайте рассмотрим новые возможности 1: 1, а затем приведем несколько советов о том, как извлечь максимальную пользу из этого выпуска, готовясь к будущему React Router.

### useParams

В React Router мы используем слово «params» для описания динамических сегментов URL. Раньше, если вы хотели получить доступ к текущим параметрам, вы должны были получить их либо с помощью проброса пропса в компонент, либо с помощью аргументов нашего рендера, например:

```js
import React from 'react'
import ReactDOM from 'react-dom'
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'

function Blog({ match }) {
    let { slug } = match.params
    // ...
}

ReactDOM.render(
    <Router>
        <div>
            <Switch>
                {/ * Использование пропса `component` * /}
                <Route path="/blog/:slug" component={BlogPost} />

                {/* Использование пропса `render` */}
                <Route
                    path="/posts/:slug"
                    render={({ match }) => <Blog match={match} />}
                />
            </Switch>
        </div>
    </Router>,
    document.getElementById('root')
)
```

Оба эти метода хороши для получения текущих параметров URL, но это не самое лучшее решение. В случае с компонентом prop маршрутизатор фактически должен создать для вас createElement (компонент), который не позволяет вам передавать пользовательские пропсы в ваш компонент <BlogPost>.
В случае рендеринга реквизита вы можете передавать пользовательские пропсы, но вы вынуждены вручную передавать значения, полученные из обратного вызова, в ваш элемент.

Кроме того, оба метода предоставляют доступ только к параметрам в <BlogPost>, поэтому вы вынуждены вручную передавать их компонентам дальше по дереву, если они вам нужны.

Лучшее выход из этой ситуации это использование хука useParams.

```js
import React from 'react'
import ReactDOM from 'react-dom'
import {
    BrowserRouter as Router,
    Route,
    Switch,
    useParams,
} from 'react-router-dom'

function Blog() {
    // Чтобы получить параметры нужно вызвать useParams (),
    let { slug } = useParams()
    // ...
}

ReactDOM.render(
    <Router>
        <div>
            <Switch>
                <Route path="/posts/:slug">
                    <Blog />
                </Route>
            </Switch>
        </div>
    </Router>,
    document.getElementById('root')
)
```

Теперь нам не нужно делать трюки с компонентами для получения параметров, просто будем использовать обычные дочерние элементы.
Мы можем использовать useParams () в любом месте <Blog> или его поддерева, не передавая параметры вручную.

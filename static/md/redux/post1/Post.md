# Redux для React: простое введение.

### Введение

Инструмент управления состоянием становится необходимостью в приложениях React, поскольку ваше состояние усложняется, одним из таких решений является Redux. Redux позволяет вам управлять всем состоянием приложения в одном объекте, который называется Store.

Обновления хранилища будут вызывать повторное рендеринг компонентов, подключенных к той части хранилища, которая была обновлена. Когда мы хотим что-то обновить, мы вызываем действие.
Мы также создаем функции для обработки этих действий и возвращаем обновленное хранилище. Эти функции называются редукторами.

Наличие «дерева состояний» в отличие от сотен состояний в сотнях компонентов имеет большой смысл.
Однако вы не обязаны использовать только Redux для хранения своего состояния: есть несколько сценариев, в которых использование глобального объекта состояния не имеет смысла, например, форм.

Почему? Формы - это отдельные части вашего приложения, состояние которых не нужно знать за пределами этой формы. (Внешние компоненты не должны знать, какие поля были проверены, отправляет ли форма, значения этой формы и т. д.). Это результат формы, которая будет полезна, так как приложение использует этот результат для внесения изменений в свое состояние.

Итак, один большой объект состояния , отлично. Как мы подключаем компоненты к состоянию? Как мы представляем изменения в состояние? Давайте ответим на эти вопросы.

В этой статье сначала будет объяснено, как инициализировать ваше хранилище (состояние Redux), затем приведены действия и объяснения редуктора, и многое другое.

Мы рассмотрим:

-   Установка пакетов Redux
-   Действия и Редукторы с примерами
-   Создание вашего первоначального магазина с помощью createStore()
-   Диспетчеризация действий с dispatch()
-   Подключение компонентов к Redux с помощью connect()
-   Некоторые файлы шаблонов, чтобы вы быстро стартовали.

### Установка

Установите в ваш проект пакеты redux и react-redux.

```js
npm install --save redux
npm install --save react-redux
```

### Инициализация вашего хранилища

Инициализация вашего хранилища может быть выполнена в вашем файле index.js или в том месте, где вы вызываете ReactDOM.render () для вашего корневого идентификатора.
Чтобы начать использовать Redux, нам нужно инициализировать хранилище и использовать компонент Redux <Provider />, чтобы сделать хранилище доступным для остальной части приложения. Это выглядит так:

```js
//...

import { Provider } from 'react-redux'
import { createStore } from 'redux'
import rootReducer from './reducers'

let initialStore = {}

const store = createStore(rootReducer, initialStore)

ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,
    document.getElementById('root')
)

//...
```

-   Импортируйте провайдера из react-redux и createStore из **redux** (да, есть 2 отдельных пакета)
-   Обратите внимание на третий импорт, rootReducer - это на самом деле наш файл index.js, который объединяет наши дочерние редукторы (подробнее о редукторах далее). Таким образом, мы фактически импортировали все редукторы в одном операторе импорта
-   Второй аргумент для createStore, initialStore, является необязательным. Если вы предварительно загружаете некоторые данные со своего сервера или сохраняете состояние из файлов cookie, то имеет смысл инициализировать ваш хранилище с такими данными здесь.

### Действия и Редукторы

Если вы прочитали несколько запутанные разделы [«Введение»](https://redux.js.org/introduction/core-concepts) и [«Основы»](https://redux.js.org/basics/basic-tutorial) на официальном веб-сайте, вы бы столкнулись с терминами «Действия и редукторы». Понимание этих терминов важно, прежде чем переходить к некоторому коду Redux.

Действия - функции, которые возвращают объект, похожий на объект JSON, описывающий, что должно > произойти. Существует один обязательный ключ с именем type. Мы должны придать каждому действию тип. Другие аргументы могут быть переданы в действие, которое может быть использовано для обновления вашего хранилища (состояния).
Редукторы - функции, которые обрабатывают действия и обновляют хранилище. Мы делаем это, возвращая новое состояние. Редукторы должны быть чистыми функциями.

### Примеры действий (Action)

Типичные шаблоны для вызова действий - это события onClick или onSubmit, в которых вы отправили действительную форму.
Давайте разберем несколько примеров действий, чтобы углубиться в концепцию:

```js
// успешный вход
// имя пользователя и authToken передаются в это определение действия
export const setSignIn = (username, authToken) => ({
    type: 'SIGN_IN', //обязательный ключ!
    user: username,
    authToken: authToken,
})
```

После аутентификации пользователя может быть вызвано действие SIGN_IN, в котором authToken и имя пользователя будут отправлены редуктору и сохранены в состоянии.

```js
// выход
// ничего не передается, так как мне просто нужно удалить редуктор
// моя аутентификация и данные пользователя
export const setSignOut = () => ({
    type: 'SIGN_OUT',
})
```

Простой пример выхода из приложения. Это действие заставит мой редуктор удалить некоторые учетные данные, которые в данный момент находятся в состоянии. Помните, что ваше хранилище доступен только для чтения, единственный способ обновить его - через действия и редукторы.

```js
// переключаем наш индикатор
// наш статус здесь может быть HIDE или SHOW
export const setProgressBar = (status) => ({
    type: 'SET_PROGRESS_BAR',
    status: status,
})
```

В следующих файлах шаблонов я приведу структуру проекта Redux и способы интеграции действий в ваш проект.

### Примеры редукторов

Редукторы реагируют на призывы к действию (или отправляют) и обрабатывают их соответствующим образом. Документация Redux рекомендуют использовать операторы switch для обработки каждого действия в вашем редукторе. Вы также можете определить несколько редукторов в отдельных файлах, чтобы сохранить ваш код организованным. Редукторы возвращают новое, обновленное состояние.
Вот как редукторы организованы в проекте:

```js
src/
   reducers/
      index.js
      ui.js
      auth.js
      ...
```

В этой настройке ui.js и auth.js будут обрабатывать действия, связанные с изменениями пользовательского интерфейса и аутентификацией. Пользовательский интерфейс, по общему признанию, довольно расплывчатый, но может включать такие вещи, как обработка индикатора выполнения вашего приложения. auth.js будет обрабатывать тип действия SIGN_IN или тип действия SIGN_OUT - и не будем забывать проверять действительные маркеры авторизации на обновлении или повторном посещении страницы, действие для которого может быть названо AUTHENTICATE_TOKEN.

-   index.js больше не определяет редукторы, а вместо этого комбинирует ui.js и auth.js, используя функцию Redux combineReducers().

Редуктор reducers/ui.js может обработать наше действие индикатора выполнения, например так:

```js
// редуктор - это просто оператор switch, который обрабатывает каждое определенное нами действие.
// редуктор возвращает новое состояние, которое, в свою очередь, обновляет Хранилище.
export const ui = (state = {}, action) => {
    switch (action.type) {
        case 'SET_PROGRESS_BAR':
            return Object.assign({}, state, {
                progressBarStatus: action.status,
            })

        default:
            return state
    }
}
export default ui
```

Этот редуктор возвращает новое состояние с одним изменением - progressBarStatus обновляет наше значение action.status.
Примечание. Если наше состояние пустое, мы присваиваем ему начальное значение пустого объекта {}.
Чтобы включить этот редуктор в наш файл редукторов индекса (или корня), мы делаем следующее:

reducers/index.js:

```js
import { combineReducers } from 'redux'
import ui from './ui'
import auth from './auth'
export default combineReducers({
    ui,
    auth,
})
```

У нас есть только 2 редуктора, но по мере роста вашего приложения вы можете легко добавлять больше в combineReducers().

Вероятно, вы можете увидеть, что происходит здесь: при каждом вызове действия (или отправке) тип действия передается через все наши файлы редуктора. Если тип действия не соответствует в каждом операторе switch, регистр по умолчанию просто возвращает текущее состояние.

### Dispatch(Рассылка) - способ вызова Действия

dispatch() - это еще одна функция Redux, которую мы используем для вызова действий. Мы можем определить отправку действия следующим образом:

```js
const dispatchSetSignedIn = dispatch(setSignedIn(username, authToken))
```

Теперь мы можем использовать dispatchSetSignedIn, например, для события onClick, которое, в свою очередь, будет проходить через конвейер Redux:

1. setSignedIn возвращает определение нашего действия в формате JSON
2. dispatchSetSignedIn отправит наши действия нашим редукторам
3. action.type проверяется для каждого оператора switch файлов Reducer. Когда правильный тип найден, он возвращает обновленное состояние
4. Наши компоненты, связанные с обновленным состоянием, будут перерисованы. Давайте рассмотрим, как это сделать, в последней части головоломки Redux.

### Подключение компонентов к хранилищю(Store)

Подключить компоненты к вашему хранилищю довольно просто. Чтобы объяснить стандартный способ приминения, давайте обратимся к идеологии типа компонента: Container и Presentational.

Конкретно, создается отдельный компонент, который действует как контейнер для компонента, к которому мы хотим подключить наше хранилище. Компонент, к которому мы хотим подключить состояние, становится нашим презентационным компонентом.

-   Компоненты-контейнеры:: обрабатывает логику, компонент, к которому мы направляем URL. Здесь ничего не отображается.

-   Презентационный компонент: Интерфейс для контейнера. Компонент Контейнер соединяет этот компонент с ним, поэтому рендеринт этот компонент.

Способ передачи состояния в ваш презентационный компонент - через props. Поэтому мы обращаемся к this.props, а не this.state при получении данных о подключенном состоянии в презентации.

### Как вы подключаете презентационный компонент к компоненту контейнеру?

Redux предоставляет 2 служебные функции, которые мы можем использовать для передачи props и распределений действий в наш презентационный компонент:

1. mapStateToProps - подключение состояния в виде пропсов для компонента (опять же, состояние из вашего Хранилища связано через пропсы)

2. mapDispatchToProps - диспетчеризация действий в качестве пропсов, позволяющая нам вызывать действия внутри компонента.

Эти 2 служебные функции определяются отдельно, за ними следует ваш контейнерный компонент. Давайте кратко рассмотрим шаблон перед полным примером:

```js
import { connect } from 'react-redux';

//Презентационный компонент
class MyComponent extends Component {

   render() {
      ...
   }
}
//state: our state is passed as the first argument here
// state(состояние): наше состояние передается в качестве первого аргумента здесь
const mapStateToProps = (state, ownProps) => {
}
// действия(actions): функция отправки Redux передается в качестве первого аргумента здесь
const mapDispatchToProps = (dispatch, ownProps) => {
}
// определяется компонент Container, передавая вышеупомянутые 2 функции в connect().
export const MyComponentContainer = connect(
 mapStateToProps,
 mapDispatchToProps
)(MyComponent);
export default MyComponentContainer
```

Таким образом, все передается из компонента Container в компонент Presentational.
Полная реализация компонента Presentation и Container определяется следующим образом:

```js
import { connect } from 'react-redux'

//Презентационный компонент
class MyComponent extends Component {
    render() {
        //...
    }
}

// состояние(state) в пропсы(props)
const mapStateToProps = (state, ownProps) => {
    return {
        itemState: state.someValue,
    }
}

// отправляем() действия в пропсы
const mapDispatchToProps = (dispatch, ownProps) => {
    return {
        handleAction: (arg) => dispatch(setMyAction(arg)),
    }
}

// Компонент контейнер
export const MyComponentContainer = connect(
    mapStateToProps,
    mapDispatchToProps
)(MyComponent)

export default MyComponentContainer
```

Взгляните на следующие моменты об этом фрагменте кода:

-   ownProps передается через mapStateToProps и mapDispatchToProps и используется для доступа к пропсам, определенным родительским компонентом MyComponentContainer.

-   В mapDispatchToProps определяются пропсы, которые вызывают действия. Мы используем dispatch() вокруг действия, чтобы фактически вызвать его, в этом случае, когда handleAction вызывается в презентации

-   Вы не обязаны определять mapStateToProps или mapDispatchToProps. В случае, если вам не нужен ни один из них, замените их на null в вашем connect (). Не смешивайте порядок: если вы только хотите определить mapDispatchToProps, поместите перед ним значение NULL, чтобы сохранить порядок размещения второго аргумента.

-   MyComponent и MyContainerComponent могут быть названы как угодно. Использование Обработчика после того, как имя Презентационного компонента является распространенным, например, Login и LoginHandler, Home и HomeHandler. Еще одно предложение - использовать Handle перед именем компонента, например, HandleLogin и Login

### Собираем все вместе

Чтобы собрать все воедино, оставшаяся часть этой статьи предоставит вам несколько шаблонов, которые можно внедрить непосредственно в ваш проект, чтобы начать работу с Redux.
Вы можете скопировать и вставить эти фрагменты в свой проект в качестве отправной точки для получения работающей структуры Redux.
Создайте следующую структуру проекта для нашей установки Redux:

```
src/
   actions/
      index.js

   components/
      MyComponent.js

   reducers/
      index.js
      ui.js
```

Следующий код содержит нашу первоначальную настройку Redux:

```js
/*
 * src/actions/index.js
 */

// не ограничивается только одним аргументом
export const setActionTemplate = (itemId) => ({
    type: 'SET_ACTION_TYPE',
    itemId: itemId,
})

// Redux также предлагает определить константы для ваших типов действий.
export const setActionTypes = {
    SET_ACTION_TYPE: 'SET_ACTION_TYPE',
}
```

```js
/*
 * src/components/MyComponent.js
 */

import React, { Component } from 'react'
import { connect } from 'react-redux'
import { setActionTemplate } from '../actions'
//component
class MyComponent extends Component {
    render() {
        const handleOnClick = () => {
            this.props.handleOnClick('your-item-id')
        }

        return (
            <div>
                <h1>My Component</h1>
                <p>
                    <a onClick={this.handleOnClick}>Dispatch Action</a>
                </p>
                <p>Current item ID: {this.props.itemId}</p>
            </div>
        )
    }
}

//redux конфигурация:
const mapStateToProps = (state, ownProps) => {
    return {
        itemId: state.itemId,
    }
}
const mapDispatchToProps = (dispatch, ownProps) => {
    return {
        handleOnClick: (itemState) =>
            dispatch(setActionTemplate(ownProps.prop)),
    }
}

export const MyComponentContainer = connect(
    mapStateToProps,
    mapDispatchToProps
)(MyComponent)

export default MyComponentContainer
```

```js
/*
 * index.js (ваш корневой DOM рендер)
 * Просто добавьте сюда код Redux, вместо того, чтобы заменить весь файл.
 */

import { Provider } from 'react-redux'
import { createStore } from 'redux'
import rootReducer from './reducers'

let initialStore = {
    itemId: 1,
}

const store = createStore(rootReducer, initialStore)

ReactDOM.render(
    <Provider store={store}>
        <App />
    </Provider>,

    document.getElementById('root')
)
```

```js
/*
 * src/reducers/childReducer.js
 */

export const childReducer = (state = {}, action) => {

  let newState;

  switch (action.type) {
   case 'SET_ACTION_TYPE':

     newState = Object.assign({}, { someValue: action.itemId);
     return newState;

   //define more cases as your project builds.
   // определите больше case по мере сборки вашего проекта.
   default:
     return state;
 }
};

export default childReducer
```

```js
/*
 * src/reducers/index.js
 */

import { combineReducers } from 'redux'
import childReducer from './childReducer'

// импортируйте и добавляйте дополнительные дочерние редукторы по мере сборки проекта.
export default combineReducers({
    childReducer,
})
```

Отлично! Если вы зашли так далеко, спасибо, что прочитали это введение в Redux.
Теперь, когда основы надежно закреплены, у вас не должно возникнуть проблем с поиском в официальной документации Redux, чтобы получить все подробности о том, как работает Redux. Наслаждайтесь программированием.

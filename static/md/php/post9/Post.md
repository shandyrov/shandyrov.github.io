# Магические методы в PHP

Методы, которые начинаются с двух знаков подчеркивания (\_\_), называются в PHP волшебными методами, и они играют важную роль.

PHP резервирует все имена функций, начинающиеся с **, как магические. Рекомендуется не использовать имена функций с ** в PHP, если вы не хотите документировать некоторые магические функции.

## \_\_construct

> Конструктор PHP - это первый метод, который автоматически вызывается после создания объекта.

> У каждого класса есть конструктор. Если вы не объявляете его явно, тогда в классе будет конструктор по умолчанию без параметров и пустого содержимого.

> Конструкторы обычно используются для выполнения некоторых задач инициализации, таких как установка начальных значений для переменных-членов при создании объектов.

> Родительские конструкторы не вызываются неявно, если дочерний класс определяет конструктор. Для запуска родительского конструктора требуется вызов parent::\_\_construct() внутри дочернего конструктора. Если дочерний элемент не определяет конструктор, он может быть унаследован от родительского класса так же, как обычный метод класса (если он не был объявлен как private)

## \_\_destruct

> Деструктор противоположен конструктору. Метод деструктора будет вызываться, если только не будет других ссылок на конкретный объект, или в любом порядке во время завершения работы.

> Деструктор позволяет вам выполнить некоторые операции перед уничтожением объекта, такие как закрытие файла, очистка результирующего набора и т. д.

> В общем, деструктор не очень распространен в PHP. Это необязательная часть класса, обычно используемая для выполнения некоторых задач очистки перед уничтожением объекта.

> Как и конструкторы, родительские деструкторы не будут вызываться движком неявно. Чтобы запустить родительский деструктор, нужно явно вызвать parent :: \_\_ destruct () в теле деструктора. Также, как и конструкторы, дочерний класс может наследовать деструктор родителя, если он сам не реализует его.

## \_\_call

Срабатывает при вызове недоступных методов в контексте объекта, когда метод не найден в этом классе.
Этот метод принимает два параметра. Первый аргумент $name - это имя вызываемого метода, а второй $arguments получает несколько аргументов метода в виде массива.

## \_\_callStatic

Срабатывает при вызове недоступных методов в статическом контексте, когда статический метод не найден в этом классе.

Этот метод принимает два параметра. Первый аргумент $name - это имя вызываемого метода, а второй $arguments получает несколько аргументов метода в виде массива.

## \_\_get

Мы можем использовать волшебный метод \_\_get () для доступа к закрытому свойству внешнего объекта.

## \_\_set

Используется для установки private свойства объекта.

Когда назначено неопределенное свойство, будет запущен метод \_\_set(), и переданные параметры - это имя и значение свойства, которые установлены.

## \_\_isset

Он запускается, когда мы вызываем isset() или empty() для недоступных свойств.

## \_\_unset

Запускается, когда мы вызываем unset() для недоступных свойств.

## \_\_sleep

Метод serialize() проверит, есть ли в классе волшебный метод \_\_sleep(). Если он существует, сначала вызывается метод, а затем выполняется операция сериализации.

Метод \_\_sleep() часто используется для указания свойств, которые необходимо сериализовать перед сохранением данных. Если есть несколько очень больших объектов, которые не нужно сохранять все, вы найдете эту функцию очень полезной.

Предполагается, что он должен вернуть массив с именами всех переменных этого объекта, который следует сериализовать. Если метод ничего не возвращает, то сериализуется NULL и выдается E_NOTICE.

\_\_sleep() не может возвращать имена private свойств в родительских классах

## \_\_wakeup

В отличие от метода **sleep(), метод **wakeup() часто используется в операциях десериализации, таких как восстановление соединения с базой данных или выполнение других операций инициализации.

## \_\_toString

Метод \_\_toString() будет вызываться при использовании метода echo для прямой вывода объекта.
Этот метод должен возвращать строку, иначе он вызовет фатальную ошибку.

## \_\_invoke

Этот метод вызывается, когда мы пытаемся вызвать объект как функцию.

## \_\_set_state

Этот статический метод вызывается для классов, экспортируемых var_export()
Если метод не определен для объекта, будут показаны все public, protected и private свойства.

## \_\_debuginfo

Этот метод вызывается функцией var_dump() при выгрузке объекта, чтобы получить свойства, которые должны отображаться.

Если метод не определен для объекта, будут показаны все public, protected и private свойства.

## \_\_clone

Копия объекта создается с помощью ключевого слова clone (котороя вызывает метод объекта \_\_clone()).
Метод объекта \_\_clone() не может быть вызван напрямую.

Метод объекта \_\_clone() не может быть вызван напрямую.

Когда объект клонируется, PHP выполняет поверхностную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.

После завершения клонирования, если определен метод **clone(), будет вызван метод **clone() вновь созданного объекта, чтобы разрешить любые необходимые свойства, которые необходимо изменить.

Все методы в одном примере:

```php
<?php
// Мы реализуем Serializable только для тестирования serialize() и unserialize()
class Car implements Serializable
{
    public $name;
    private $hidden = 'Serect';

    // __construct ([ mixed $args = "" [, $... ]] ) : void
    function __construct($name = null)
    {
        $this->name = $name;
        echo ("Constructor is called\n");
    }

    public function say()
    {
        echo "My name is $this->name\n";
    }

    // __destruct ( void ) : void
    function __destruct()
    {
        echo "Destroying " . __class__ . "\n";
    }

    // public __call ( string $name , array $arguments ) : mixed
    public function __call($name, $arguments)
    {
        echo "Calling object method '$name', Arguments: " . implode(', ', $arguments) . "\n";
    }

    // public static __callStatic ( string $name , array $arguments ) : mixed
    public static function __callStatic($name, $arguments)
    {
        echo "Calling static method '$name', Arguments: " . implode(', ', $arguments) . "\n";
    }

    // public __set ( string $name , mixed $value ) : void
    public function __set($name, $value)
    {
        echo "Setting '$name' to '$value'\n";
        $this->$name = $value;
    }

    // public __get ( string $name ) : mixed
    public function __get($name)
    {
        echo "Getting '$name'\n";
        return $this->$name;
    }

    // public __isset ( string $name ) : bool
    public function __isset($name)
    {
        echo "Is '$name' set?\n";
        return isset($this->$name);
    }

    // public __unset ( string $name ) : void
    public function __unset($name)
    {
        echo "Unsetting '$name'\n";
        unset($this->$name);
    }

    // public __sleep ( void ) : array
    public function __sleep()
    {
        echo "Вызывается, потому что метод serialize() вызывается вне класса \n"
        $this->name = base64_encode($this->name);
        // should return an array
        return array('name');
    }

    public function __wakeup()
    {
        echo "Вызывается, когда метод unserialize() вызывается вне класса. <br>"
        $this->name = 'Mr. Bean';
        // Здесь нет необходимости возвращать массив.
    }

    public function serialize()
    {
        return serialize('hello world');
    }

    public function unserialize($serialized)
    {
        $this->name = unserialize($serialized);
    }

    // public __toString ( void ) : string
    public function __toString()
    {
        return "Beautiful Car\n";
    }

    // __invoke ([ $... ] ) : mixed
    public function __invoke($x = true)
    {
        var_dump($x);
    }

    // static __set_state ( array $properties ) : object
    public static function __set_state($an_array)
    {
        $obj = new Car;
        $obj->name = $an_array["name"];

        return $obj;
    }

    // __debugInfo ( void ) : array
    public function __debugInfo()
    {
        return ['name' => 'Debug Name'];
    }

    // __clone ( void ) : void
    public function __clone()
    {
        echo "You are cloning the object\n";
    }

}

// вызывается __construct
$bmw = new Car('X1');
$bmw->say();
// класс не имеет методов runTest(), поэтому вызывается __call
$bmw->runTest('Hi', 123);
// класс не имеет статических методов runTest(), поэтому вызывается __callStatic
Car::runTest('Hello', 123);
echo "\n";

// класс не имеет private свойства 'aaa', поэтому вызывается __set
$bmw->aaa = 1;
// класс имеет private свойство hidden, поэтому вызывается __set
$bmw->hidden = "Hacked";
// класс имеет общедоступное свойство name, поэтому __set не вызывается
$bmw->name = "X8";
echo "\n";

// класс не имеет private свойства 'aaa', поэтому __get не вызывается
echo $bmw->aaa . "\n";
// класс имеет private свойство hidden, поэтому вызывается __get
echo $bmw->hidden . "\n";
// класс имеет общедоступное свойство name, поэтому вызывается __get
echo $bmw->name . "\n";
echo "\n";

// класс имеет private свойство 'hidden', поэтому вызывается __isset
var_dump(isset($bmw->hidden));
// класс имеет private свойство hidden, поэтому вызывается __unset
unset($bmw->hidden);
var_dump(isset($bmw->hidden));
echo "\n";

// класс имеет public свойство name, поэтому __isset не вызывается
var_dump(isset($bmw->name));
// класс имеет public свойство name, поэтому __unset не вызывается
unset($bmw->name);
// Теперь свойство 'name' не установлено, поэтому __isset вызывается для поиска его private свойств.
var_dump(isset($bmw->name));
echo "\n";

// Сериализация вызовет метод __sleep
echo (serialize($bmw));
// unserialize вызовет метод __wakeup
// также вызовется метод __destruct
echo (unserialize(serialize($bmw)));
echo "\n";

// Метод __toString() будет вызываться при использовании метода echo для прямой печати объекта.
echo $bmw;
// Когда вы пытаетесь вызвать объект как функцию, метод __invoke будет вызываться автоматически.
echo $bmw();
echo "\n";

// Метод __set_state() вызывается var_export()
$someCar = new Car('Some Name');
$someCar->name = "Honda";
eval('$b = ' . var_export($someCar, true) . ';');
echo var_export($b);
echo "\n";

// Метод __debugInfo() вызывается var_dump() при выгрузке объекта, чтобы получить свойства, которые должны быть показаны
var_dump(new Car("poll"));
echo "\n";

// __clone() будет вызываться при выполнении клонирования
$fromSomeCar = clone $someCar;
```

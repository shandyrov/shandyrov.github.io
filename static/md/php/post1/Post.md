# Что нового в PHP 7.0

В этой статье мы рассмотрим некоторые новые функции, представленные в PHP 7, и то, как использовать эти новые возможности.

Ниже приведены некоторые из новых функций PHP 7:

- Объявления скалярных типов
- Объявления возвращаемых значений
- Оператор объединения с null (??)
- Оператор spaceship (космический корабль <=>)
- Определение констант массивов с помощью define()
- Анонимные классы
- Синтаксис кодирования Unicode
- Closure::call()
- unserialize() с фильтрацией
- IntlChar
- Ожидания (Expectations)
- Групповые объявления use
- Выражение return в генераторах
- Делегация генератора
- Функция целочисленного деления intdiv()
- Опции сессий
- preg_replace_callback_array()
- Функции CSPRNG

## Объявления скалярных типов

Объявления типов - это то, что позволяет функции запрашивать определенные типы параметров во время вызова. Есть два типа объявлений скалярных типов: один является принудительным или вы можете сказать, что он используется по умолчанию, а другой - строгим.

Параметры типа: строки (string), целые числа (int), числа с плавающей запятой (float) и логические значения (bool).

## Тип по умолчанию или принудительный

```php
function returnsum(float $x, float $y) {
    return $x + $y;
}

returnsum(6, "8 days");
//вывод float(14)

returnsum(4.1, "4.2");
//вывод float(8.3)
```

## Strict Type

```php
declare(strict_types=1);
function returnsum(float $a, float $b)
 {
return $a + $b;
}

returnsum(3.1, 2.1);
// output float(5.2)

returnsum(3, "2 days");
// Fatal error
```

## Объявления возвращаемых значений

Как и объявление типа параметра, объявление типа возвращаемого значения - это тип значения, которое вы хотите вернуть из функции.

## Базовый тип или тип по умолчанию для объявления возвращаемых значений

```php
function add($a, $b): float {
    return $a + $b;
}

var_dump(add(1, 2));
// output will be float(3)
```

## Строгий тип объявлений возвращаемого типа

```php
declare(strict_types=1);
function add($a, $b): int {
    return $a + $b;
}

var_dump(add(1, 2));
var_dump(add(1, 2.5));
// output will be
// int(3)
// Fatal error
```

## Оператор объединения с null (??)

Оператор объединения с нулевым значением представлен в виде двух вопросительных знаков ??. Он используется для проверки того, установлено ли значение или значение null, или, другими словами, если значение существует, и не null, тогда он возвращает первый операнд, в противном случае он возвращает второй операнд.

Пример:

```php
// Получает значение $ _GET ['username'] и возвращает 'not define'
// если его не существует.
$username = $_GET['username'] ?? 'not define';
// Это то же самое:
$username = isset($_GET['username']) ? $_GET['username'] : 'not define';
// Объединение можно объединить в цепочку: это вернет первое
// определенное значение из $ _GET ['username'], $ _POST ['username'] и
// 'not define'.
$username = $_GET['username'] ?? $_POST['username'] ?? 'not define';
```

## Оператор spaceship (космический корабль <=>)

Оператор космического корабля представлен следующим образом <=>. Он используется для сравнения двух выражений и возврата -1, 0, 1, когда одна переменная меньше, равна или больше по сравнению с другой переменной.

Пример:

```php
// Integers
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1
```

## Определение констант массивов с помощью define()

В PHP 7 вы также можете определить массив как константу, используя команду define.

Пример:

```php
define('USERNAME', array('John','Smith','Mike'));

echo USERNAME[1]; // outputs "Smith"
```

## Анонимные классы

Создание экземпляров объектов из классов - довольно простое действие. Мы используем ключевое слово new, за которым следует имя класса и возможные параметры конструктора. Часть имени класса подразумевает существование ранее определенного класса. Хотя и редко, но есть случаи, когда классы используются только во время выполнения. Эти редкие случаи усложняют принудительное определение класса отдельно, когда мы знаем, что класс используется только один раз. Чтобы решить эту проблему многословия, PHP представил новую функциональность, называемую анонимными классами. В то время как концепция анонимных классов существует уже некоторое время в других языках, PHP реализовал ее только в версии PHP 7.

## Синтаксис кодирования Unicode

Он принимает шестнадцатеричный код Unicode и записываем его в формате UTF-8 в двойных кавычках или формате heredoc. Любой корректный код будет принят. Ведущие нули по желанию.

```php
echo "\u{aa}";
echo "\u{0000aa}";
echo "\u{9999}";
```

## Closure::call()

Closure::call() является более производительным и коротким способом временного связывания области действия объекта с замыканием и его вызовом.

## unserialize() с фильтрацией

Этот функционал обеспечивает более высокий уровень безопасности при десериализации объектов с непроверенными данными. Это позволяет предотвратить возможную инъекцию кода, позволяя разработчику использовать белый список классов для десериализации.

```php
<?php

// Преобразование всех объектов в __PHP_Incomplete_Class
$data = unserialize($foo, ["allowed_classes" => false]);

// Преобразование всех объектов, кроме MyClass и MyClass2 в __PHP_Incomplete_Class
$data = unserialize($foo, ["allowed_classes" => ["MyClass", "MyClass2"]]);

// Поведение по умолчанию принимает все классы (можно просто не задавать второй аргумент)
$data = unserialize($foo, ["allowed_classes" => true]);
```

## IntlChar

Новый класс IntlChar добавляет новую функциональность в ICU. Класс определяет несколько статических методов и констант для манипулирования символами Unicode.
Для использования это класса необходимо установить расширение Intl.

```php
<?php

printf('%x', IntlChar::CODEPOINT_MAX);
echo IntlChar::charName('@');
var_dump(IntlChar::ispunct('!'));
// Вывод
10ffff
COMMERCIAL AT
bool(true)
```

## Ожидания (Expectations)

Ожидания являются улучшенной, обратно совместимой версией старой функции assert(). Они позволяют делать предположения с нулевой стоимостью в промышленном коде и предоставляют возможность выбрасывать пользовательские исключения в случае провала ожидания.

Вместе тем, что старое API поддерживается, assert() теперь является языковой конструкцией, принимающей первым аргументом выражения, а не только строки (string) для оценки или логические значения (bool) для проверки.

```php
<?php
ini_set('assert.exception', 1);

class CustomError extends AssertionError {}

assert(false, new CustomError('Сообщение об ошибке'));

// Вывод
Fatal error: Uncaught CustomError: Сообщение об ошибке
?>
```

## Групповые объявления use

Классы, функции и константы импортируемые из одного и того же namespace, теперь можно группировать в одном операторе use.

```php
<?php
// До PHP 7
use some\namespace\ClassA;
use some\namespace\ClassB;
use some\namespace\ClassC as C;

use function some\namespace\fn_a;
use function some\namespace\fn_b;
use function some\namespace\fn_c;

use const some\namespace\ConstA;
use const some\namespace\ConstB;
use const some\namespace\ConstC;

// PHP 7+
use some\namespace\{ClassA, ClassB, ClassC as C};
use function some\namespace\{fn_a, fn_b, fn_c};
use const some\namespace\{ConstA, ConstB, ConstC};
?>
```

## Выражение return в генераторах

Эта функциональность добавлена к генераторам, введенным в PHP 5.5. Она позволяет использовать оператор return в генераторах в качестве окончательного возвращаемого значения (возврат по ссылке недопустим). Это значение можно извлечь с помощью нового метода Generator::getReturn(), который можно использовать только после того, как генератор вернул все сгенерированные значение.

```php
<?php

$gen = (function() {
    yield 1;
    yield 2;

    return 3;
})();

foreach ($gen as $val) {
    echo $val, PHP_EOL;
}

echo $gen->getReturn(), PHP_EOL;

// Вывод
1
2
3
```

Возможность явно получать окончательное значение генератора является очень полезной, так как позволяет клиентскому коду, использующему генератор, получать и обработать самое последнее значение генератора, после которого точно ничего больше не будет. Это сильно проще, чем вынуждать разработчика проверять, последнее ли значение вернулось и как-то по особенному его обрабатывать.

## Делегация генератора

Теперь генератор может автоматически делегировать другому генератору, объекту класса, реализующий Traversable или массиву без необходимости писать в нем дополнительную обработку полученных значений. Достигается это с помощью конструкции yield from.

```php
<?php
function gen()
{
    yield 1;
    yield 2;
    yield from gen2();
}

function gen2()
{
    yield 3;
    yield 4;
}

foreach (gen() as $val)
{
    echo $val, PHP_EOL;
}

// Вывод
1
2
3
4
?>
```

## Функция целочисленного деления intdiv()

Новая функция intdiv() производит целочисленное деление операндов и возвращает его результат.

```php
<?php
var_dump(intdiv(10, 3));
?>

// Вывод
int(3)

```

## Опции сессий

Теперь session_start() принимает массив опций, которые переопределят конфигурационные директивы сессии установленные в php.ini.

Также опции были расширены включенной по умолчанию опцией session.lazy_write, которая говорит PHP о том, что файл сессии надо перезаписывать, только если изменились данные сессии, и опцией read_and_close, которую можно задать только через session_start() для того, чтобы PHP закрывал сессию сразу же как прочитает ее данные и не вносил в нее каких-либо изменений.

К примеру, для установки session.cache_limiter равным private и немедленному закрытию сессии после чтения ее данных:

```php
<?php
session_start([
    'cache_limiter' => 'private',
    'read_and_close' => true,
]);
?>
```

## preg_replace_callback_array()

Новая функция preg_replace_callback_array() позволяет писать более чистый код, когда требуется использовать функцию preg_replace_callback(). До PHP 7 при необходимости обработать разные регулярные выражения разными функциями приходилось для каждой такой обработки писать отдельный вызов функции.

Теперь можно использовать одну функцию, передавая в нее ассоциативный массив, ключами которого являются регулярные выражения, а значениями - функции обратного вызова.

## Функции CSPRNG

Были добавлены две новые кроссплатформенные функции для генерации криптографически безопасных строк и целых чисел: random_bytes() и random_int().

## Теперь функция list() всегда может распаковывать объекты, реализующие ArrayAccess

Ранее функция list() не гарантировала корректную обработку объектов, реализующих ArrayAccess. Теперь это исправлено.

### Материал взят с сайта: [www.php.net](https://www.php.net/manual/ru/migration70.new-features.php)
